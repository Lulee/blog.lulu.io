(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{424:function(i,t,s){"use strict";s.r(t);var e=s(44),_=Object(e.a)({},(function(){var i=this,t=i.$createElement,s=i._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[s("h1",{attrs:{id:"前端面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端面试题"}},[i._v("#")]),i._v(" 前端面试题")]),i._v(" "),s("h3",{attrs:{id:"_1-箭头函数不适合的场景有哪些-为什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-箭头函数不适合的场景有哪些-为什么"}},[i._v("#")]),i._v(" 1. 箭头函数不适合的场景有哪些，为什么？")]),i._v(" "),s("ul",[s("li",[i._v("不适合做对象的方法")]),i._v(" "),s("li",[i._v("不能作为构造函数")]),i._v(" "),s("li",[i._v("不能定义原型方法")])]),i._v(" "),s("p",[i._v("因为箭头函数不绑定 this，以上场景都需要动态绑定 this，所以不适合使用箭头函数。")]),i._v(" "),s("h3",{attrs:{id:"_2-this-作用场景哪些-并分别指代什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-this-作用场景哪些-并分别指代什么"}},[i._v("#")]),i._v(" 2. this 作用场景哪些，并分别指代什么？")]),i._v(" "),s("ul",[s("li",[i._v("默认绑定，非严格模式，this 执行 window, 严格模式，this 指向 undefined")]),i._v(" "),s("li",[i._v("对象的方法，this指向对象")]),i._v(" "),s("li",[i._v("构造函数，this 指向实例对象")]),i._v(" "),s("li",[i._v("显示绑定，call,bind，apply 方法显示指定 this")])]),i._v(" "),s("h3",{attrs:{id:"_3-promise-是什么-有哪些特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-promise-是什么-有哪些特点"}},[i._v("#")]),i._v(" 3. promise 是什么，有哪些特点？")]),i._v(" "),s("p",[i._v("Promise 是异步编程的一种解决方案，简单说是一个容易，保存着某个未来结束的事件的结果。promise 是一个对象，有两个特点：")]),i._v(" "),s("ol",[s("li",[i._v("Promise对象的状态不受外界影响。promise 对象有三种状态：pending（进行中），fulfilled（已成功），rejected（已失败）。")]),i._v(" "),s("li",[i._v("一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise对象的状态改变只有两种可能，从pending 到 fulfilled，从 pending到 rejected.")])]),i._v(" "),s("p",[i._v("Promise的缺点：")]),i._v(" "),s("ol",[s("li",[i._v("无法取消 promise，一旦创建成功就会立即执行，无法中途取消。")]),i._v(" "),s("li",[i._v("如果不设置回调函数，promise 内部抛出的错误不会反映到外部。")]),i._v(" "),s("li",[i._v("当处于 pending 状态，无法得知进度。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);